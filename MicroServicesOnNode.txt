
Monolith:

-Technology first J2EE, Domain Next.


Team: OMS - PM- More PLS
1. DEV
2. TESTING
3. RELEASE
4. OPERATIONS


1.Req
2.Design
   High Level-UML,Database
   Low level - Runtime,databases,tools......
3.coding

-Vendor-lock in : Mono-lithic
   -DEV,TESTING,PRODUCTION.
-Work flow is highly sequencial
   Req -Complete
   Dev
   testing
   Release
   Production
  Delay in delivery:Cost increased
-Production cost was huge

Data Centers
 -need to purchase high powered servers - bare metal servers
 
Cost:
   -Hardware
   -OS -Linux-Ubuntu
   -Tools -Servers,databases etc....
   -Matrix Hell -  Mapping software components in dev and Production..


How to build enterprise jee based app.

App  must support a variety of different clients including desktop browsers. 

The application might also expose an API for 3rd parties to consume.

It might also integrate with other applications via a message broker. 

The application handles requests (HTTP requests and messages) by executing business logic; 

accessing a database; 

exchanging messages with other systems;

and returning a HTML/JSON/XML response. 

There are logical components corresponding to different functional areas of the application.

............................................................................................

IF App needs to talk to external systems like Message Brokers, other Systems like Main frames.

RPC/RPI
MOM
Connectors Arch.

BIZ LOGIC:

1- Service Layer : isloate service layer into separate component

 can be inside one app - one layer, that layer may run on different jvms -  distributed Arch.


Layer :

 Client ---- Web Layer  ----Service Layer ---- Repository Layer

/////////////////////////////////////////////////////////////////////////////////////////////

Packaging Model:
 
WAR - Web archive
EAR .

Problems with Single JAR/WAR:

1. Scalability
 Vertical scablitity
 Horzitional scability 

2.Deployments
    -Bare Metal Deployment

////////////////////////////////////////////////////////////////////////////////////////////
Monoloith distributed app development drabackbacks:

-Time is taken for project delivery
   -Requirements 
   -High level design and low level design
   -coding
   -testing
   -release
   -production- live

-Technology Stack and Vendor lock in
   -You need to build the entire app using one technology or one vendor product
    eg: J2EE, Oracle,Weblogic

-Production and maintance cost
  -You need to setup large data centers , you need to maintain them.

Companies like amzon,netflix,google wanted to change the app development model.
                                "Micro services"


Micro services are architural model of req,dev,test,relase,production,maintaince different ways.
    Continous req collecting
    Continous dev
    Continuous testing
    Continuous release
    Continuous deployment
    Using rented data centers: Cloud

-Domain First, Technology Next: Domain Driven Design.
-No Vendor lock- Multi tech stack.
-Indidual dev , deployment - orders is development ,tested,deployed,customers are developed,tested deployment.
   -Parrel dev.
-Automation -dev ops
   release - CI 
   deployment - Containerized - Docker..
-Introduction of Cloud computing
..............................................................................................

                                  Micro Services Design Pattern
..............................................................................................


Implementation Patterns:
........................

1.DOMAIN Models
  Decompose by biz features
  Decompose by sub domains

2.Development
  -Object oriented Design
 Class
      -Represent something in domain eg :Order,Customer
 Service
     -Offerings : giving something to somebody.
   A Program offers something - Data

Services can be broken into smllar and smallar based on domains
   Telecom domain :
       Telecommunication Services
		-Data Service
			- Mobile data
			- Broad Band
			    -Fiber
                            -leased Line
    
    FiberOpticService
        -getSpeed - 
        -increaseSpeed-
        -getNewConnection-
        -disconnectExisingConnection() 
        -payBills()    

   BillingService
	generateBill
	processPayment
	sendBill
        adjustBill
  
   How to design a Service? 
	USING SOLID Principles

  Single-responsibility principle -SRP

/////////////////////////////////////////////////////////////////////////////////////////////

Service Communications:
 
   Two Domains are going to collbrate each other to carry a biz transaction.


In Micro Services


FiberOpticService
     is 
   Running 
     inside
 One Application
       |
     Runtime
       |
  VM -Container

      OS
 
     |
     |   data
     |

Billing is Running
     is 
   Running 
     Another
 One Application
      |
     Runtime
       |
  VM -Container

      OS

Class ----will become  Objects

Object Communication === Service Communication



-SAME JVM(Runtime)
  Calling methods from one object(FiberDataService) to another object (BillingService).
-Different Runtime(JVM)
   -Networks - Protocals
    RestFull
      -HTTP 
   -RPC/RIP
	-ORB
        -RMI
        -gRpc
   -MOM - Message Brokers
        RabbitMQ
	Kaffka
	etc...
   -Event Bus
	-TCP

/////////////////////////////////////////////////////////////////////////////////////////////

Sevices Are Eagar or Lazy:
.........................
 

Eagar Service expects data immediatly.

Service waits for data until it is received.The service cant continue other jobs ; 

Sync Services

Drawbacks:

- Blocking 
    It leads performance issues

Service does not wait for data until it is received.The service t continue other jobs ; 

Async Services

Advantages
 - Non Blocking
    
Async Services Implementation:
..............................

Two ways:

1.Programmetic level 
    -Netty,webflux,Quarkus,Moleculre

2.Via Message Brokers
    RabbitMQ,Kafka


///////////////////////////////////////////////////////////////////////////////////////////

Service Failures:
.................

1.UnAvailability

2.Timeout due to slow calls

How to handle failures , how to return proper response to caller?

Reliability Design patterns :fault tolerance 

 -Circuit Breaker
 -Bulk Head
 -Rate Limiter
 -Retry
 -TimeLitmiter
 -Cache

///////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////

Service Communications in network and its Problems:
...................................................

Services are going to talk each other.

If they want to talk, What services should know each other?

 -Location
     ip address

In monolithic(traditional) deployment - ip address , ports are well known (hardcoded)
but in containers/ cloud env which are highly dynamic.

Where Micro services typically runs in a virtualized or containerized envs , locations are highly.

Services need to be registered some where and others services will ask registered location, that , hey give me that service

Service Registry and Discovery Pattern:
.......................................
Service Registry:
  -database - stores service informations

Service Discovery:
  locating services from the service registry

Types of Service discovery:
 -Client Side Service Discovery
 -Server Side Service Discovery
.............................................................................................
.............................................................................................

Data Management :

 A Service need to store data in data sources - Database
  
Database Per Service.

 FiberOpticService
Each service has its own schema. 
you can have more than one tables per service

Database: 
  Collection of tables,views,other objects

Shared Database:
  Sharing db for more than one services .
/////////////////////////////////////////////////////////////////////////////////////////////

Service Communication and Data Management

How to implement Transactions In Microservices?

It is very very difficult to implement and track transactions across multiple services.

Transactional Designpattern:

1.2PC  - 2 Phase Commit

2.Saga
    -EDA - Event Driven Architectures
  Saga Implementation
	-Choreography
        -Orchestration
//////////////////////////////////////////////////////////////////////////////////////////

.............................................................................................

Data Management :

 A Service need to store data in data sources - Database
  
Database Per Service.

 FiberOpticService
Each service has its own schema. 
you can have more than one tables per service

Database: 
  Collection of tables,views,other objects

Shared Database:
  Sharing db for more than one services .


Service Communication and Data Management

How to implement Transactions In Microservices?

It is very very difficult to implement and track transactions across multiple services.

Transactional Designpattern:

1.2PC  - 2 Phase Commit

2.Saga
    -EDA - Event Driven Architectures
  Saga Implementation
	-Choreography
        -Orchestration
//////////////////////////////////////////////////////////////////////////////////////////

Micro Services Management Patterns:

1.Log Managements
     Distributed/Centralized log management.
 
Tools:
   Graylog - mongodb,ES,Graylog
   ELK Stack  - ES,Logstash,kibana
   EFK Stack  - ES,Fluentd,Kibana


2.Application Metrics
     To monitor Application behaviours

Tools:
   Prometheus
   AWS Cloud Watch

3.Auditing
    User auditing,application auditing - Performance
    Record User activties in a databse

4.Distributed Tracing /Tracking
   If i want to track service calls
    A -->B ---C -- Something
   You can Track Exception Hierachies
  
 Open zipkin
 Open Tracing

5.Health Check Api
    To test health of apis,infra components.

 Some implemetations provides health endpoints where you can get helath metrics information
that can be feed to tools 

-Prometheus
////////////////////////////////////////////////////////////////////////////////////////////
				Micro Services - Implementations
............................................................................................

Microservices is langugage,platform,os independant. 

Java:
 -Spring Cloud
 -Quarkus
 -Light4J
 -Vertx
 etc...

Javascript : nodejs


                                   Moleculer

Progressive microservices framework for Node.js

Moleculer is framework which has implemented most of common microservices design patterns.

Moleculer features:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
7.plugin/middleware system
8.support versioned services
9.support Streams
10.service mixins
11.built-in caching solution (Memory, MemoryLRU, Redis)
12.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
13.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
14.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
15.pluggable parameter validator
16.multiple services on a node/server
17.master-less architecture, all nodes are equal
18.parameter validation with fastest-validator
19.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
20.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
21.official API gateway, Database access and many other modules…

https://moleculer.services/

Moleculer setup:

project creations;

1.from begining like normal node application.
2.moleculer cli- to setup realtime project with all artifacts.

npm install moleculer


Core concepts in Molecular:
..........................

1.Service
 A service is a simple JavaScript module containing some part of a complex application. 
 A service represents a biz logic in your application.

2.Service Broker : == Spring Container
 Service Broker is the heart of Moleculer.

It is responsible for management and communication between services (local and remote). 

3.node :
 A node is a simple OS process running on a local or external network.
 A single instance of a node can host one or many services.
 node js platform - v8+libvu..

Each node must have an instance of Service Broker.

"Service Broker is one single Node instance - Node runtime"

4.Transporter
	Transporter is a communication bus that services use to exchange messages. 
 It transfers events, requests and responses.

5.Gateway
     API Gateway exposes Moleculer services to end-users.
 The gateway is a regular Moleculer service running a (HTTP, WebSockets, etc.) server. It handles the incoming requests, maps them into service calls, and then returns appropriate responses.

///////////////////////////////////////////////////////////////////////////////////////////

Services:

1.HTTP services
   Services are exposed for outsideworld

2.Back end services
   Services are used to encasulate biz logics like database operations,any biz


service names and file names:

math.service.js
hello.service.js


service broker creation and start:

const { ServiceBroker } = require('moleculer')

//ServiceBroker is Moleculer Engine , on which only create services and deploy them.
const broker = new ServiceBroker()

function main() {
    broker.start()
        .then(() => {
            console.log('Moleculer is ready to serve')
        })
        .catch(err => console.log(`Molculer failed to start ${err}`))
}
main()


Create Service:

-Service is object
-Service represents a biz feature
-Service object is created by broker.createService factory method
-createService methods takes service schema as parameter.

const { ServiceBroker } = require('moleculer')

//ServiceBroker is Moleculer Engine , on which only create services and deploy them.
const broker = new ServiceBroker()

//Service
broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello MicroService'
        }
    }
})




function main() {
    broker.start()
        .then(() => {
            console.log('Moleculer is ready to serve')
            //here only we can call service methods
            broker.call('hello.sayHello')
                .then(response => console.log(response))
                .catch(err => console.log(`Service call is failed ${err}`))
        })
        .catch(err => console.log(`Molculer failed to start ${err}`))
}
main()

Refactoring Code:
async function main() {
    try {
        await broker.start()
        const response = await broker.call('hello.sayHello')
        console.log(response)
    }
    catch (err) {
        console.log(err)
    }
}

main()
////////////////////////////////////////////////////////////////////////////////////////////


const { ServiceBroker } = require('moleculer')

//ServiceBroker is Moleculer Engine , on which only create services and deploy them.
const broker = new ServiceBroker()

//Service
broker.createService({
    name: 'hello',
    actions: {
        sayHello(ctx) {
            const { message,name } = ctx.params;
            return `${message} ${name}`
        }
    }
})

async function main() {
    try {
        await broker.start()
        let response = await broker.call('hello.sayHello', { message: 'Hello' ,name:'Subramanian' })
        console.log(response)
        response =await broker.call('hello.sayHello', { message: 'Hello' ,name:'Microservices' })
        console.log(response)
    }
    catch (err) {
        console.log(err)
    }
}

main()
/////////////////////////////////////////////////////////////////////////////////////////////
const { ServiceBroker } = require('moleculer');
const { log } = console;

const broker = new ServiceBroker();

//multiple service methods
broker.createService({
    name: 'profile',
    actions: {
        findAll() {
            return 'Profile findall'
        },
        save() {
            return 'profile save'
        },
        remove() {
            return 'profile remove'
        }

    }
});


async function init() {
    try {
        await broker.start();
        let response;
        response= await broker.call('profile.findAll')
        log(`${response}`)
        response= await broker.call('profile.save')
        log(`${response}`)
        response= await broker.call('profile.remove')
        log(`${response}`)
    }
    catch (e) {
        log(e);
    }
}
init();
///////////////////////////////////////////////////////////////////////////////////////////////

Single Broker Multiple Services:
................................

const { ServiceBroker } = require('moleculer');
const { log } = console;
const broker = new ServiceBroker();

//Hello Service
broker.createService({
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello() {
            return 'Hello,Molecular'
        }
    }
});

broker.createService({
    name: 'hai',
    actions: {
        //define biz api of that service
        sayHai() {
            return 'Hai,Molecular'
        }
    }
});


broker.createService({
    name: 'greet',
    actions: {
        //define biz api of that service
        sayGreet() {
            return 'Greet,Molecular'
        }
    }
});

async function init() {
    try {
        await broker.start();
        let response;
        response= await broker.call('hello.sayHello')
        log(`${response}`)
        response= await broker.call('hai.sayHai')
        log(`${response}`)
        response= await broker.call('greet.sayGreet')
        log(`${response}`)
    }
    catch (e) {
        log(e);
    }
}
init();
/////////////////////////////////////////////////////////////////////////////////////////////

How to define meta information for service methods?

-validation
-caching

eg : 
 sayHello(ctx){
    ctx.params.name
 }
here i want to enable validation rule for name that
 name must be string.

Without meta information
  actions: {
        //define biz api of that service
        sayGreet() {
            return 'Greet,Molecular'
        }
    }

With meta information

actions: {

  sayGreet : {
     
 	  //validation behaviour
            params: {
                message: "string"       
            },
            //logic, inside a method called handler
            handler(ctx) {
               return 'Greet'
            } 

  }

}

eg:
const { ServiceBroker } = require('moleculer');
const { log } = console;
const broker = new ServiceBroker();


broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: "number",
                b: "number"
            },
            handler(ctx) {
                const { a, b } = ctx.params;
                return a + b;
            }
        }
    }

})

async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('math.add', { a: 10, b: 10 })
        log(response);
        response = await broker.call('math.add', { a: "10", b: 10 })
        log(response);
    }
    catch (e) {
        log(e);
    }
}
init();
//////////////////////////////////////////////////////////////////////////////////////////

Service Types:
.............

1.Back end services
------------------------
1.local services
2.remote services
3.public services
4.private services
---------------------------------
Front end services

1.HTTP services



1.local services :
 services are written and running on a "Single Service Broker  and Node".

how local services are communicating? service calls.

Service Communication:

how local services are communicating? service calls.

how to call service?

1.broker.call -  outside service
2.ctx.call -  service to service  

-Local Service Communication:
............................

Within Node/Broker.

const { ServiceBroker } = require('moleculer');
const { log } = console;

const broker = new ServiceBroker();

//calculator service
broker.createService({
    name: 'calculator',
    actions: {
        add: {
            params: {
                a: 'number',
                b: 'number'
            },
            async handler(ctx) {
                const { a, b } = ctx.params;
                //service call
                // ctx.call('adder.add', { a: a, b: b })
                let res = await ctx.call('adder.add', { a, b })
                return res
            }

        }
    }
})

//adder service
broker.createService({
    name: 'adder',
    actions: {
        add: {
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params;
                return a + b;
            }

        }
    }
})


async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('calculator.add', { a: 10, b: 20 })
        log(response)
    }
    catch (e) {
        log(e);
    }
}
init();
////////////////////////////////////////////////////////////////////////////////////////////

REPL Mode: Read Evualate Print Loop : Interactive Command Line.

REPL feature provide by node .

>node
Welcome to Node.js v14.17.0.
Type ".help" for more information.
> .help
.break    Sometimes you get stuck, this gets you out
.clear    Alias for .break
.editor   Enter editor mode
.exit     Exit the REPL
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands in this REPL session to a file

Press Ctrl+C to abort current expression, Ctrl+D to exit the REPL
> .clear
> a =20
20
> b=90
90
> c = a + b
110
>

molecular provides REPL Mode.

For dev testing.

if i want to test a service with various different parameters during runtime.
if i want to adminster services

>npm install moleculer-repl --save-dev


Uses :

- interactive service testing.
- for monitoring services,actions ; administrative tasks.


Service calls in repl prompt.
 $ call "adder.add"  --a 10 --b 20

mol $ help

  Commands:

    help [command...]                                          Provides help for a given command.
    q                                                          Exit application
    actions [options]                                          List of actions
    bench [options] <action> [jsonParams] [meta]               Benchmark a service
    broadcast <eventName>                                      Broadcast an event
    broadcastLocal <eventName>                                 Broadcast an event locally
    cache keys [options]                                       List keys of cache entries
    cache clear [pattern]                                      Clear cache entries
    call [options] <actionName> [jsonParams] [meta]            Call an action
    dcall [options] <nodeID> <actionName> [jsonParams] [meta]  Direct call an action
    clear [pattern]                                            Clear cache entries
    cls                                                        Clear console
    destroy <serviceName> [version]                            Destroy a local service
    emit <eventName>                                           Emit an event
    env                                                        List of environment variables
    events [options]                                           List of event listeners
    info                                                       Information about broker
    load <servicePath>                                         Load a service from file
    loadFolder <serviceFolder> [fileMask]                      Load all services from folder
    metrics [options]                                          List metrics
    nodes [options]                                            List of nodes
    services [options]                                         List of services


Molecular Provides two types of services

1.$node : built in service
 -for administrative service

2.services are created by application dev.
.............................................................................................

					Remote Services
				     (Distributed Services)
.............................................................................................

Remote Services
-Services are located across the nodes.
-nodes can be the same machine or different machines, or cloud.


Steps:
1.main service

services/remotemain.service.js
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    nodeID: 'IBM-MainServer',
    transporter: "nats://localhost:4222"
});

broker.createService({
    name: 'main',
    actions: {
        async begin(ctx) {
            const { a, b } = ctx.params
            let res = await ctx.call('remote1.calculate', { a, b })
            console.log(`Result Got From Remote Services ${res}`)
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();

services/remote1.service.js

const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    nodeID: 'IBM-RemoteNode-1'
});

broker.createService({
    name: 'remote1',
    actions: {
        async calculate(ctx) {
            const { a, b } = ctx.params
            return await ctx.call('remote2.calculate', { a, b })
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();

services/remote2.service.js

const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    nodeID: 'IBM-RemoteNode-2'
});

broker.createService({
    name: 'remote2',
    actions: {
        async calculate(ctx) {
            const { a, b } = ctx.params
            return a + b;
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();


2.Open three command prompt and run the services

2.1.C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted>node services/remotemain.service.js



2.2.C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted>node services/remote1.service.js

2.3.C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted>node services/remote2.service.js

3.start service communication from remotemain.service.js

mol $ call "main.begin" --a 10 --b 20
>> Call 'main.begin' with params: { a: 10, b: 20 }
[2021-07-01T09:09:44.788Z] WARN  IBM-MainServer/BROKER: Service 'remote1.calculate' is not registered.
Result Got From Remote Services [object Promise]
>> Execution time:5ms
>> Response:
undefined
mol $ (node:12900) UnhandledPromiseRejectionWarning: ServiceNotFoundError: Service 'remote1.calculate' is not found.
    at ServiceBroker.findNextActionEndpoint (C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\service-broker.js:1034:13)
    at ServiceBroker.call (C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\service-broker.js:1083:26)
    at Context.call (C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\context.js:289:23)
    at Service.begin (C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\services\remotemain.service.js:12:27)
    at C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\utils.js:185:22
    at ServiceBroker.timeoutMiddleware (C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\middlewares\timeout.js:35:14)
    at ServiceBroker.fallbackMiddleware (C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\middlewares\fallback.js:29:11)
    at ServiceBroker.errorHandlerMiddleware (C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\middlewares\error-handler.js:14:10)
    at ServiceBroker.call (C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\service-broker.js:1098:31)
    at call (C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer-repl\src\commands\call.js:90:9)
(Use `node --trace-warnings ...` to show where the warning was created)
(node:12900) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 3)
(node:12900) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.

Why the above error?

-Service not able to locate the other service, since other services are running in different 
nodes
.............................................................................................
					 Networking
.............................................................................................

In order to enable Remote Service communications , we need Message Brokers 


Transporters:

-Transporter is an important module if you are running services on multiple nodes. 

-Transporter communicates with other nodes. 

-It transfers events, calls requests and processes responses …etc. 

-If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.


Transports:
............

Built-in transporters

TCP transporter
NATS Transporter
Redis Transporter
MQTT Transporter
AMQP Transporter
Kafka Transporter
NATS Streaming (STAN) Transporter


Steps;

1.you have to run Transporter broker software

 like redis server or nats server ,AMQP server.....

NATS: Bridge :https://nats.io/download/

docker run  --name nats-main -p 4222:4222 -p 6222:6222 -p 8222:8222 nats


2.you have to install transport adapter/driver

npm install nats@1.4.12 --save



3.Configure nats transporter with broker

    transporter: "nats://localhost:4222"

>node services/remotemain.service.js
[2021-07-01T09:35:40.787Z] INFO  IBM-MainServer/BROKER: Moleculer v0.14.14 is starting...
[2021-07-01T09:35:40.790Z] INFO  IBM-MainServer/BROKER: Namespace: <not defined>
[2021-07-01T09:35:40.791Z] INFO  IBM-MainServer/BROKER: Node ID: IBM-MainServer
[2021-07-01T09:35:40.793Z] INFO  IBM-MainServer/REGISTRY: Strategy: RoundRobinStrategy
[2021-07-01T09:35:40.794Z] INFO  IBM-MainServer/REGISTRY: Discoverer: LocalDiscoverer
[2021-07-01T09:35:40.809Z] INFO  IBM-MainServer/BROKER: Serializer: JSONSerializer
[2021-07-01T09:35:40.828Z] INFO  IBM-MainServer/BROKER: Validator: FastestValidator
[2021-07-01T09:35:40.831Z] INFO  IBM-MainServer/BROKER: Registered 13 internal middleware(s).
[2021-07-01T09:35:40.835Z] INFO  IBM-MainServer/TRANSPORTER: NATS lib version: 1.4.12
[2021-07-01T09:35:40.835Z] INFO  IBM-MainServer/BROKER: Transporter: NatsTransporter
[2021-07-01T09:35:40.856Z] INFO  IBM-MainServer/TRANSIT: Connecting to the transporter...
[2021-07-01T09:35:40.910Z] INFO  IBM-MainServer/TRANSPORTER: NATS client v1 is connected.
[2021-07-01T09:35:40.924Z] INFO  IBM-MainServer/REGISTRY: Node 'IBM-RemoteNode-2' connected.
[2021-07-01T09:35:40.926Z] INFO  IBM-MainServer/REGISTRY: Node 'IBM-RemoteNode-1' connected.
[2021-07-01T09:35:41.426Z] INFO  IBM-MainServer/REGISTRY: '$node' service is registered.
[2021-07-01T09:35:41.427Z] INFO  IBM-MainServer/REGISTRY: 'main' service is registered.
[2021-07-01T09:35:41.428Z] INFO  IBM-MainServer/$NODE: Service '$node' started.
[2021-07-01T09:35:41.429Z] INFO  IBM-MainServer/MAIN: Service 'main' started.
[2021-07-01T09:35:41.435Z] INFO  IBM-MainServer/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 580ms.
mol $ call "main.begin" --a 10 --b 20
>> Call 'main.begin' with params: { a: 10, b: 20 }
Result Got From Remote Services 30
>> Execution time:12ms
>> Response:
undefined
mol $ call "main.begin" --a 10 --b 70
>> Call 'main.begin' with params: { a: 10, b: 70 }
Result Got From Remote Services 80
>> Execution time:12ms
>> Response:
undefined
mol $
/////////////////////////////////////////////////////////////////////////////////////////////

		              Service Registry and Discovery
.............................................................................................

1.Service Registry

 It is mini /small database , key-value pair database, in memory database.
 Which has all service,actions,event listeners, nodes information.

Points:
1.Every Broker has in built Service Registry
     Moleculer has built in in-memory registry, we can use that registry directly.

2.All services local or remote are registered with service registry as soon you create 
  service
3.Molecular has built in registry called LocalDiscoveryRegistry, which is not using third party registry servers
  like apache zoo keeper,cosule,etcd,eurka....

4.if you want to make other servers as service registry -

    registry: {
        discoverer: "redis://redis-server:6379"
    }  


What is discovery?
   
   Discovery  means the lookup, search, we are going to search "services" from the registry infra structure.

         "All Services when is created is registered in Service Registry"

Moleculer looks up services from the registry by name.


Registry logs:

[2021-07-01T11:03:37.313Z] INFO  IBM-MainServer/REGISTRY: Strategy: RoundRobinStrategy
[2021-07-01T11:03:37.314Z] INFO  IBM-MainServer/REGISTRY: Discoverer: LocalDiscoverer

[2021-07-01T11:03:37.445Z] INFO  IBM-MainServer/REGISTRY: Node 'IBM-RemoteNode-1' connected.
[2021-07-01T11:03:37.448Z] INFO  IBM-MainServer/REGISTRY: Node 'IBM-RemoteNode-2' connected.
[2021-07-01T11:03:37.947Z] INFO  IBM-MainServer/REGISTRY: '$node' service is registered.
[2021-07-01T11:03:37.948Z] INFO  IBM-MainServer/REGISTRY: 'main' service is registered.


How to change new Service Registry/Discover?

Redis  as Service Registry.

Steps:

1.Start Redis Server.

docker run  -p 6379:6379 redis

2.install redis driver
npm install ioredis --save

const broker = new ServiceBroker({
    nodeID: 'IBM-MainServer',
    transporter: "nats://localhost:4222",
    registry: {
        //discoverer:'Redis'
        discoverer: "redis://localhost:6379"
    }
});
node services/remotemain.service.js
[2021-07-01T11:13:09.882Z] INFO  IBM-MainServer/BROKER: Moleculer v0.14.14 is starting...
[2021-07-01T11:13:09.886Z] INFO  IBM-MainServer/BROKER: Namespace: <not defined>
[2021-07-01T11:13:09.886Z] INFO  IBM-MainServer/BROKER: Node ID: IBM-MainServer
[2021-07-01T11:13:09.888Z] INFO  IBM-MainServer/REGISTRY: Strategy: RoundRobinStrategy
[2021-07-01T11:13:09.890Z] INFO  IBM-MainServer/REGISTRY: Discoverer: RedisDiscoverer
[2021-07-01T11:13:09.909Z] INFO  IBM-MainServer/BROKER: Serializer: JSONSerializer
[2021-07-01T11:13:09.927Z] INFO  IBM-MainServer/BROKER: Validator: FastestValidator
[2021-07-01T11:13:09.930Z] INFO  IBM-MainServer/BROKER: Registered 13 internal middleware(s).
[2021-07-01T11:13:09.933Z] INFO  IBM-MainServer/TRANSPORTER: NATS lib version: 1.4.12
[2021-07-01T11:13:09.934Z] INFO  IBM-MainServer/BROKER: Transporter: NatsTransporter
[2021-07-01T11:13:10.032Z] WARN  IBM-MainServer/DISCOVERY: Redis Discoverer is an EXPERIMENTAL module. Do NOT use it in production!
[2021-07-01T11:13:10.057Z] INFO  IBM-MainServer/TRANSIT: Connecting to the transporter...
[2021-07-01T11:13:10.102Z] INFO  IBM-MainServer/DISCOVERY: Redis Discoverer client connected.
[2021-07-01T11:13:10.115Z] INFO  IBM-MainServer/TRANSPORTER: NATS client v1 is connected.
[2021-07-01T11:13:10.630Z] INFO  IBM-MainServer/REGISTRY: '$node' service is registered.
[2021-07-01T11:13:10.631Z] INFO  IBM-MainServer/REGISTRY: 'main' service is registered.
[2021-07-01T11:13:10.632Z] INFO  IBM-MainServer/$NODE: Service '$node' started.
[2021-07-01T11:13:10.633Z] INFO  IBM-MainServer/MAIN: Service 'main' started.
[2021-07-01T11:13:10.850Z] INFO  IBM-MainServer/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 7
//////////////////////////////////////////////////////////////////////////////////////////////
			Scaleablity and High Availability
.............................................................................................

Scalling Means, increasing/decreasing resources.
Resources could be hardware resources or software resources.

Types of Scaleability:

1.Vertical 
   increasing hardware resources
2.Horziontal
   increasing software resources.


In distributed Programming(microservices), we need to clone the services n of times in order
serve to all clients effectivly.: Horziontal scaling.

When scale services, it is difficult to route the service calls to service instances because the same service instance exits in multiple copies.

How to select which service instance to be assigned to caller(client), 

   With help of Load Balancer.

Load Balancer balances incomming load and route according ot "router algorthims" provided by load balancers.


Built-in strategies

 ->RoundRobin strategy
	This strategy selects a node based on round-robin algorithm.
   Refer:https://en.wikipedia.org/wiki/Round-robin_DNS
 ->Random strategy
	This strategy selects a node randomly.
 ->CPU usage-based strategy
	This strategy selects a node which has the lowest CPU usage. Due to the node list can 	be very long, it gets samples and selects the node with the lowest CPU usage from only 	samples instead of the whole node list.

 ->Latency-based strategy
	This strategy selects a node which has the lowest latency, measured by periodic ping commands. Notice that the strategy only ping one of nodes from a single host.

///////////////////////////////////////////////////////////////////////////////////////////

How to implement load balancing?

1.You need to clone the services n- number of times.
  lets say i have service called "adder" service , i need to run adder service 2 instances

2.Each service is going to run in different nodes. Each node must be identified quickly.
  Node name should not be hardcoded.
  In Genernal Node Id would be  - computername_processId
  

Steps:

1.Run remote2 service two times
open two cmd prompt and run.

>node services/remote2.service.js
>node services/remote2.service.js



const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    // nodeID: 'IBM-RemoteNode-2',
    transporter: "nats://localhost:4222",
    registry: {
        strategy:"Random"
        //discoverer:'Redis'
     //   discoverer: "redis://localhost:6379"
    }

});

broker.createService({
    name: 'remote2',
    actions: {
        async calculate(ctx) {
            const { a, b } = ctx.params
             return `${a + b} - ${broker.nodeID} `;
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();



2021-07-02T05:00:26.207Z] INFO  laptop-r2tggfdl-11556/BROKER: Moleculer v0.14.14 is starting...
[2021-07-02T05:00:26.209Z] INFO  laptop-r2tggfdl-11556/BROKER: Namespace: <not defined>
[2021-07-02T05:00:26.210Z] INFO  laptop-r2tggfdl-11556/BROKER: Node ID: laptop-r2tggfdl-11556
[2021-07-02T05:00:26.211Z] INFO  laptop-r2tggfdl-11556/REGISTRY: Strategy: RandomStrategy
[2021-07-02T05:00:26.212Z] INFO  laptop-r2tggfdl-11556/REGISTRY: Discoverer: LocalDiscoverer
[2021-07-02T05:00:26.219Z] INFO  laptop-r2tggfdl-11556/BROKER: Serializer: JSONSerializer
[2021-07-02T05:00:26.230Z] INFO  laptop-r2tggfdl-11556/BROKER: Validator: FastestValidator
[2021-07-02T05:00:26.233Z] INFO  laptop-r2tggfdl-11556/BROKER: Registered 13 internal middleware(s).
[2021-07-02T05:00:26.234Z] INFO  laptop-r2tggfdl-11556/TRANSPORTER: NATS lib version: 1.4.12
[2021-07-02T05:00:26.235Z] INFO  laptop-r2tggfdl-11556/BROKER: Transporter: NatsTransporter
[2021-07-02T05:00:26.244Z] INFO  laptop-r2tggfdl-11556/TRANSIT: Connecting to the transporter...
[2021-07-02T05:00:26.271Z] INFO  laptop-r2tggfdl-11556/TRANSPORTER: NATS client v1 is connected.
[2021-07-02T05:00:26.279Z] INFO  laptop-r2tggfdl-11556/REGISTRY: Node 'IBM-MainServer' connected.
[2021-07-02T05:00:26.280Z] INFO  laptop-r2tggfdl-11556/REGISTRY: Node 'laptop-r2tggfdl-9556' connected.
[2021-07-02T05:00:26.282Z] INFO  laptop-r2tggfdl-11556/REGISTRY: Node 'IBM-RemoteNode-1' connected.
[2021-07-02T05:00:26.780Z] INFO  laptop-r2tggfdl-11556/REGISTRY: '$node' service is registered.
[2021-07-02T05:00:26.781Z] INFO  laptop-r2tggfdl-11556/REGISTRY: 'remote2' service is registered.
[2021-07-02T05:00:26.784Z] INFO  laptop-r2tggfdl-11556/$NODE: Service '$node' started.
[2021-07-02T05:00:26.786Z] INFO  laptop-r2tggfdl-11556/REMOTE2: Service 'remote2' started.
[2021-07-02T05:00:26.791Z] INFO  laptop-r2tggfdl-11556/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 548ms.

/////////////////////

2.node services/remote1.service.js


3.node services/remotemain.service.js
>> Call 'main.begin' with params: { a: 10, b: 20 }
Result Got From Remote Services 30 - laptop-r2tggfdl-11556
>> Execution time:4ms
>> Response:
undefined
mol $ call "main.begin" --a 10 --b 20
>> Call 'main.begin' with params: { a: 10, b: 20 }
Result Got From Remote Services 30 - laptop-r2tggfdl-9556
>> Execution time:7ms
>> Response:
undefined
mol $
/////////////////////////////////////////////////////////////////////////////////////////////

High Availablity:

 Making Services  always available, to reduce down time. 

 How to achive highly available?

  You need to scale, and load balance.
...........................................................................................
				   Fault Management : Reliability
...........................................................................................

Distributed Env is subject to fail.

Failures in Distributed Computing is always expected.

What could be Failures?

For a Caller (Who is requesting service/who is calling Service) Point of View.

-Timeout

    Service-X  is calling Service-Y

1.You may get Result(succees/errors) "on time".

2.YOu may not get any thing beyond time.

3.Timeout defines deadlines for services


eg:
   Service-X expects result in 500 ms from Service-Y, What if Service-Y not able to give result within that time lime , Service-Y will throw TimeoutException.

Now you need to decide how to Handle TimeoutException?

 -throw exception and handle it
 -You can have alternate fallback api to return result to the caller.


Fault Management Implementations In Moleculer:
..............................................

1.Timeout.

Fault Management algorthims can be defined in two places

1.At Broker Level
 -if you set fault management algorthims at ServiceBroker level,those settings will be appliable for the entier application.

let broker = new ServiceBroker({
    requestTimeout: 5 * 1000 // in milliseconds

})



2.At Service Level

 Sometimes if you want to override default settings

 broker.call("posts.find", {}, { timeout: 3000 });
 ctx.call("posts.find", {}, { timeout: 3000 });

///////////////////////////////////////////////////////////////////////////////////////////

Caller Service  Expects , That data should be returned from Callee in 1000 ms , but Callee
returns Data in 4000ms. , Timeout Exception will be thrown.


Steps: 1 : caller Service

const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    nodeID: 'IBM-MainServer',
    transporter: "nats://localhost:4222",

    registry: {
        //discoverer:'Redis'
       // discoverer: "redis://localhost:6379"
    }
});

broker.createService({
    name: 'main',
    actions: {
        async begin(ctx) {
            const { a, b } = ctx.params
            let res = await ctx.call('remote1.calculate', { a, b },{
                    timeout: 1000
             })
            console.log(`Result Got From Remote Services ${res}`)
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();


Step 2: Callee:
................

Callee Level-1 :

const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    nodeID: 'IBM-RemoteNode-1',
    transporter: "nats://localhost:4222",
    registry: {
        //discoverer:'Redis'
       // discoverer: "redis://localhost:6379"
    }

});

broker.createService({
    name: 'remote1',
    actions: {
        async calculate(ctx) {
            const { a, b } = ctx.params
            return await ctx.call('remote2.calculate', { a, b })
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();


Callee-Level 2
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    // nodeID: 'IBM-RemoteNode-2',
    transporter: "nats://localhost:4222",
    registry: {
        strategy:"Random"
        //discoverer:'Redis'
     //   discoverer: "redis://localhost:6379"
    },
    requestTimeout: 5 * 1000 // in milliseconds

});

broker.createService({
    name: 'remote2',
    actions: {
        async calculate(ctx) {
            const { a, b } = ctx.params
            // return `${a + b} - ${broker.nodeID} `;
             return new Promise((resolve,reject)=>{
                 setTimeout(resolve,4000,`${a + b} - ${broker.nodeID} `)
             })
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();

Out Come:

node services/remotemain.service.js
[2021-07-02T05:37:00.812Z] INFO  IBM-MainServer/BROKER: Moleculer v0.14.14 is starting...
[2021-07-02T05:37:00.814Z] INFO  IBM-MainServer/BROKER: Namespace: <not defined>
[2021-07-02T05:37:00.814Z] INFO  IBM-MainServer/BROKER: Node ID: IBM-MainServer
[2021-07-02T05:37:00.815Z] INFO  IBM-MainServer/REGISTRY: Strategy: RoundRobinStrategy
[2021-07-02T05:37:00.816Z] INFO  IBM-MainServer/REGISTRY: Discoverer: LocalDiscoverer
[2021-07-02T05:37:00.826Z] INFO  IBM-MainServer/BROKER: Serializer: JSONSerializer
[2021-07-02T05:37:00.839Z] INFO  IBM-MainServer/BROKER: Validator: FastestValidator
[2021-07-02T05:37:00.841Z] INFO  IBM-MainServer/BROKER: Registered 13 internal middleware(s).
[2021-07-02T05:37:00.843Z] INFO  IBM-MainServer/TRANSPORTER: NATS lib version: 1.4.12
[2021-07-02T05:37:00.844Z] INFO  IBM-MainServer/BROKER: Transporter: NatsTransporter
[2021-07-02T05:37:00.861Z] INFO  IBM-MainServer/TRANSIT: Connecting to the transporter...
[2021-07-02T05:37:00.900Z] INFO  IBM-MainServer/TRANSPORTER: NATS client v1 is connected.
[2021-07-02T05:37:00.909Z] INFO  IBM-MainServer/REGISTRY: Node 'laptop-r2tggfdl-4416' connected.
[2021-07-02T05:37:00.910Z] INFO  IBM-MainServer/REGISTRY: Node 'laptop-r2tggfdl-13180' connected.
[2021-07-02T05:37:00.912Z] INFO  IBM-MainServer/REGISTRY: Node 'IBM-RemoteNode-1' connected.
[2021-07-02T05:37:01.409Z] INFO  IBM-MainServer/REGISTRY: '$node' service is registered.
[2021-07-02T05:37:01.410Z] INFO  IBM-MainServer/REGISTRY: 'main' service is registered.
[2021-07-02T05:37:01.412Z] INFO  IBM-MainServer/$NODE: Service '$node' started.
[2021-07-02T05:37:01.413Z] INFO  IBM-MainServer/MAIN: Service 'main' started.
[2021-07-02T05:37:01.419Z] INFO  IBM-MainServer/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 559ms.
mol $ call "main.begin" --a 10 --b 20
>> Call 'main.begin' with params: { a: 10, b: 20 }
[2021-07-02T05:37:17.518Z] WARN  IBM-MainServer/BROKER: Request 'remote1.calculate' is timed out. { requestID: '5e20d57c-0694-4767-b120-34e478ad0023', nodeID: 'IBM-RemoteNode-1', timeout: 1000 }
>> ERROR:
RequestTimeoutError: Request is timed out when call 'remote1.calculate' action on 'IBM-RemoteNode-1' node.
    at C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\middlewares\timeout.js:42:14
    at async Service.begin (C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\services\remotemain.service.js:18:23)
Data:  { action: 'remote1.calculate', nodeID: 'IBM-RemoteNode-1' }
mol $

The above code  throws Timeout Exception.

What if i dont want Timout Exception?

  You need to set fallback.

Fallback is a function gets called , if execption is Thrown.

Fallback function may return data from "cache" Servers.


broker.createService({
    name: 'main',
    actions: {
        async begin(ctx) {
            const { a, b ,timeout } = ctx.params
            let res = await ctx.call('remote1.calculate', { a, b }, {
               // timeout: 1000,
                timeout:timeout,
                fallbackResponse() {
                    //return data from caching server
                    return `The Result is From cachining Server ${0}`
                }
            })
            console.log(`Result Got From Remote Services ${res}`)
        }
    }
})

Testing:
mol $ call "main.begin" --a 10 --b 20 --timeout 2000
>> Call 'main.begin' with params: { a: 10, b: 20, timeout: 2000 }
[2021-07-02T05:49:21.958Z] WARN  IBM-MainServer/BROKER: Request 'remote1.calculate' is timed out. { requestID: '2d946322-4668-4df5-9c92-acd97ae48811', nodeID: 'IBM-RemoteNode-1', timeout: 2000 }
[2021-07-02T05:49:21.960Z] WARN  IBM-MainServer/BROKER: The 'remote1.calculate' request is failed. Return fallback response. { requestID: '2d946322-4668-4df5-9c92-acd97ae48811', err: "Request is timed out when call 'remote1.calculate' action on 'IBM-RemoteNode-1' node." }
Result Got From Remote Services The Result is From cachining Server 0
>> Execution time:2s
>> Response:
undefined
mol $ call "main.begin" --a 10 --b 20 --timeout 5000
>> Call 'main.begin' with params: { a: 10, b: 20, timeout: 5000 }
Result Got From Remote Services 30 - laptop-r2tggfdl-13180
>> Execution time:4s
>> Response:
undefined
mol $

How to set Global Timeout from the caller side?


const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    nodeID: 'IBM-MainServer',
    transporter: "nats://localhost:4222",
    requestTimeout: 1000, // in milliseconds,

    registry: {
        //discoverer:'Redis'
        // discoverer: "redis://localhost:6379"
    }
});

broker.createService({
    name: 'main',
    actions: {
        async begin(ctx) {
            const { a, b ,timeout } = ctx.params
            // let res = await ctx.call('remote1.calculate', { a, b }, {
            //    // timeout: 1000,
            //     timeout:timeout,
            //     fallbackResponse() {
            //         //return data from caching server
            //         return `The Result is From cachining Server ${0}`
            //     }
            // })
            //which uses global timeout
             let res = await ctx.call('remote1.calculate', { a, b })
            console.log(`Result Got From Remote Services ${res}`)
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();
/////////////////////////////////////////////////////////////////////////////////////////////
				Circuit Breaker
.............................................................................................

CircuitBreaker: 

Automatically fail fast when execution repeatedly fails.

CB is a state machine with three states:
  CLOSED, OPEN, HALF_OPEN

CLOSED : No exception,No Problm in the System.
 if service is working fine, then cb state would be closed.

OPEN:
   if something went wrong, cb opens a cb, tries to trip , never allows further calls

 Service A -----calls -----Service B

 Cb allows serviceA to call Service B if no error/exception.

 cb will never allow ServiceA to call Service B if exception is thrown.

HALF_OPEN:
   if service need to recover from failures to normal state  , cb will go to half_open state 

 from half_open to Open :  still failures are there in the system
 from half_open to closed : Recovered from failures, system is normal
 


How to implement CB in Moleculer?

1.Broker level : Global cb settings

const broker = new ServiceBroker({
    circuitBreaker: {
        enabled: true,
        threshold: 0.5,
        minRequestCount: 20,
        windowTime: 60, // in seconds
        halfOpenTime: 5 * 1000, // in milliseconds
        check: err => err && err.code >= 500
    }
});

enable: Enable feature
threshold	
   Number	0.5	
   Threshold value. 0.5 means that 50% should be failed for tripping.
minRequestCount	
   Number	20	
  Minimum request count. Below it, CB does not trip (It never goes to open state)

windowTime	
   Number	60	
 Number of seconds for time window.

halfOpenTime	
  Number	10000
 Number of milliseconds to switch from open to half-open state

check	Function	err && err.code >= 500	A function to check failed requests.


2.Service level : Only for particular services

broker.createService({
{
    name: "users",
    actions: {
        create: {
            circuitBreaker: {
                // All CB options can be overwritten from broker options.
                threshold: 0.3,
                windowTime: 30
            },
            handler(ctx) {}
        }
    }
};
})
//////////////////////////////////////////////////////////////////////////////////////////////

Steps:

1.services/remotemain.service.js
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    nodeID: 'IBM-MainServer',
    transporter: "nats://localhost:4222",
    // requestTimeout: 1000, // in milliseconds,
    circuitBreaker: {
        enabled: true,
        threshold: 0.1,
        minRequestCount: 1,
        windowTime: 60, // in seconds
        halfOpenTime: 5 * 1000, // in milliseconds
        check: err => {
            console.log('check function -Main')
            console.log(err)
            return err && err.code >= 500
        }
    },
    registry: {
        //discoverer:'Redis'
        // discoverer: "redis://localhost:6379"
    }
});

broker.createService({
    name: 'main',
    events: {
        "$circuit-breaker.opened"(opened) {
            console.log("main CB open created -Main service:", opened.nodeID ,opened.action);
        },
        "$circuit-breaker.closed"(opened) {
            console.log("main CB closed created -Main service:", opened.nodeID ,opened.action);
        },
        "$circuit-breaker.half-opened"(opened) {
            console.log("main CB Half created -Main service:", opened.nodeID ,opened.action);
        }
       
    },
    actions: {
        // async begin(ctx) {
        //     //  const { a, b ,timeout } = ctx.params
        //     const { a, b, invocationNumber } = ctx.params
        //     // let res = await ctx.call('remote1.calculate', { a, b }, {
        //     //    // timeout: 1000,
        //     //     timeout:timeout,
        //     //     fallbackResponse() {
        //     //         //return data from caching server
        //     //         return `The Result is From cachining Server ${0}`
        //     //     }
        //     // })
        //     //which uses global timeout
        //     let res = await ctx.call('remote1.calculate', { a, b, invocationNumber })
        //     console.log(`Result Got From Remote Services ${res}`)
        // }
        begin: {
            circuitBreaker: {
                // All CB options can be overwritten from broker options.
                threshold: 0.0,
                windowTime: 30
            },
            fallback: (ctx, err) => `Data From Caching Server ${0}`,
            async handler(ctx) {
                const { a, b, invocationNumber } = ctx.params
                let res = await ctx.call('remote1.calculate', { a, b, invocationNumber })
                console.log(`Result Got From Remote Services ${res}`)

            }

        }

    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();

services/remote2.service.js
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    // nodeID: 'IBM-RemoteNode-2',
    transporter: "nats://localhost:4222",
    registry: {
        strategy: "Random"
        //discoverer:'Redis'
        //   discoverer: "redis://localhost:6379"
    },
    requestTimeout: 5 * 1000, // in milliseconds
    circuitBreaker: {
        enabled: true,
        threshold: 0.1,
        minRequestCount: 1,
        windowTime: 60, // in seconds
        halfOpenTime: 5 * 1000, // in milliseconds
        check: err => {
            console.log('check function-service2')
            return err && err.code >= 500
        }
    }
});

broker.createService({
    name: 'remote2',
    events: {
        "$circuit-breaker.opened"(opened) {
            console.log("remote2 : CB open created -Main service:", opened.nodeID ,opened.action);
        },
        "$circuit-breaker.closed"(opened) {
            console.log("remote2 : CB closed created -Main service:", opened.nodeID ,opened.action);
        },
        "$circuit-breaker.half-opened"(opened) {
            console.log("remote2 : CB Half created -Main service:", opened.nodeID ,opened.action);
        }
       
    },
    actions: {
        async calculate(ctx) {
            const { a, b, invocationNumber } = ctx.params
            // // return `${a + b} - ${broker.nodeID} `;
            return new Promise((resolve, reject) => {
                //setTimeout(resolve,4000,`${a + b} - ${broker.nodeID} `)
                if (invocationNumber === 10) {
                    setTimeout(reject, 4000, `Something went wrong`)
                } else {
                    setTimeout(resolve, 4000, `${a + b} - ${broker.nodeID} `)
                }
            })
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();



output:
>> Call 'main.begin' with params: { a: 10, b: 10, invocationNumber: 10 }
check function -Main
MoleculerError: Something went wrong
    at C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\middlewares\error-handler.js:17:12 {
  code: 500,
  type: undefined,
  data: undefined,
  retryable: false,
  nodeID: 'laptop-r2tggfdl-20672'
}
check function -Main
MoleculerError: Something went wrong
    at C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\middlewares\error-handler.js:17:12 {
  code: 500,
  type: undefined,
  data: undefined,
  retryable: false,
  nodeID: 'laptop-r2tggfdl-20672'
}
[2021-07-02T07:49:52.916Z] WARN  IBM-MainServer/MAIN: The 'main.begin' request is failed. Return fallback response. { requestID: '719df089-01e0-446e-9f47-f2284cfee860', err: 'Something went wrong' }
>> Execution time:4s
>> Response:
'Data From Caching Server 0'
mol $ call "main.begin" --a 10 --b 10 --invocationNumber 10
>> Call 'main.begin' with params: { a: 10, b: 10, invocationNumber: 10 }
check function -Main
MoleculerError: Something went wrong
    at C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\middlewares\error-handler.js:17:12 {
  code: 500,
  type: undefined,
  data: undefined,
  retryable: false,
  nodeID: 'laptop-r2tggfdl-20656'
}
check function -Main
MoleculerError: Something went wrong
    at C:\session\ibm\2021\june\nodemicroservices\ms-gettingstarted\node_modules\moleculer\src\middlewares\error-handler.js:17:12 {
  code: 500,
  type: undefined,
  data: undefined,
  retryable: false,
  nodeID: 'laptop-r2tggfdl-20656'
}
[2021-07-02T07:50:00.132Z] WARN  IBM-MainServer/MAIN: The 'main.begin' request is failed. Return fallback response. { requestID: 'c17f9ddc-43df-465f-a374-2dd128b5391a', err: 'Something went wrong' }
>> Execution time:4s
>> Response:
'Data From Caching Server 0'
mol $ call "main.begin" --a 10 --b 10 --invocationNumber 14
>> Call 'main.begin' with params: { a: 10, b: 10, invocationNumber: 14 }
Result Got From Remote Services 20 - laptop-r2tggfdl-20672
main CB open created -Main service: IBM-MainServer main.begin
>> Execution time:4s
>> Response:
undefined
mol $ main CB Half created -Main service: IBM-MainServer main.begin
mol $ call "main.begin" --a 10 --b 10 --invocationNumber 14
>> Call 'main.begin' with params: { a: 10, b: 10, invocationNumber: 14 }
Result Got From Remote Services 20 - laptop-r2tggfdl-20656
main CB closed created -Main service: IBM-MainServer main.begin
>> Execution time:4s
>> Response:
undefined
mol $
//////////////////////////////////////////////////////////////////////////////////////////////
                                 Event Driven Architecture- EDA
.............................................................................................


- A Service can emit event ,  Another service can listens events.

- If nodes are running in different machines, we can send and receive messages via transporters

Broker has a built-in event bus to support Event-driven architecture and to send events to local and remote services.


Register Events:

 {
    name: "payment",
    events: {
        "order.created": {
            // Register handler to the "other" group instead of "payment" group.
            group: "other",
            handler(payload) {
                // ...
            }
        }
    }
}

      "user.created"(user) {
            console.log("User created:", user);
        }

Emit Event

broker.emit("order.created", order);
ctx.emit("order.created",order)

broker.broadcast("config.changed", config);

emit vs broadcast

emit - one to one

broadcast - one to many  - pub -sub


Steps:

services/producer.service.js

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "nats://localhost:4222"
})

broker.createService({
    name: 'producer',
    actions: {
        sayHello(ctx) {
            const { message } = ctx.params;
            ctx.emit('producer.message', `${message} from ${ctx.nodeID}`);
        }
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err)
    }
}

main()

services/consumer.service.js
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "nats://localhost:4222"
})

broker.createService({
    name: 'consumer',
    events: {
        "producer.message"(message) {
            console.log(message)
        }
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err)
    }
}

main()

ol $ call "producer.sayHello" --message Hello
>> Call 'producer.sayHello' with params: { message: 'Hello' }
>> Execution time:4ms
>> Response:
undefined
mol $

[2021-07-02T09:19:53.695Z] INFO  laptop-r2tggfdl-16576/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 546ms.
mol $ Hello from laptop-r2tggfdl-3124

////////////////////////////////////////////////////////////////////////////////////////////

				Service inheritance

Objective:

 lets say i have a service having more methods, that i dont want to give in a service
 i have service , that service apis , i want to reuse in service apis

Service inheritance comes into place.

In molecular , a service can inherit many services - multi level, for multi level, molcular uses a concept called "mixins".


Use case:
1.if you write any REST Controller.
2.if you write database operations inside your service.


How to write services in a different file
How to do inheritance(service mixins) - mixin means multilevel 


services/parent.service.js


//service is exported
module.exports = {
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello() {
            return 'Hello,Moleculer'
        }
    }
};


services/child.service
const { ServiceBroker } = require('moleculer');
const hello = require('./parent.service');
const { log } = console;
const broker = new ServiceBroker();

broker.createService({
    name: 'greeter',
    mixins: [hello], //service inheritance done
    actions: {
        sayGreet(){
            return 'Hai'
        }
    }
})
async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('greeter.sayHello')
        log(`${response}`)
        response = await broker.call('greeter.sayGreet')
        log(`${response}`)

    }
    catch (e) {
        log(e);
    }
}
init();
/////////////////////////////////////////////////////////////////////////////////////////////
					Methods
//////////////////////////////////////////////////////////////////////////////////////////////

1.public methods
2.private methods
3.life cycle methods - broker cycle, service life cycle
4.HTTP end point methods. 

const { ServiceBroker } = require('moleculer');
const { log } = console;
const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        //public methods
        calculate(ctx) {
          //calling private method
          const result=this.add(ctx.params.a,ctx.params.b);
          return result
        }
    },
    //private methods
    methods: {
        add(a,b){
            return a +b;
        }
    }
});

async function init() {
    try {
        await broker.start();
        let response;
        //calling public methods
        response = await broker.call('math.calculate', { a: 10, b: 20 });
        log(response);

    }
    catch (e) {
        log(e);
    }
}
init();
////////////////////////////////////////////////////////////////////////////////////////////
LifeCycles:
const { ServiceBroker } = require('moleculer');
const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        add(ctx) {
            return ctx.params.a + ctx.params.b;
        }
    },
    //life cycle methods
    created() {
        // Fired when the service instance created (with `broker.loadService` or `broker.createService`)
        this.logger.info("created");
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        this.logger.info("started");
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        this.logger.info("stoped");
    }
})


async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('math.add', { a: 1, b: 3 })
        console.log(`response ${response}`)
    }
    catch (e) {
        log(e);
    }
}
init();
/////////////////////////////////////////////////////////////////////////////////////////////
				Moleculer Modules
/////////////////////////////////////////////////////////////////////////////////////////////

Moleculer offers lot of moudules called libs for extending the basic framework.

-Web Features
-Database features
-Messaging features
etc..........


Mixin:
   Help to integrate any plugin into our services

Modules:
 How integrate modules into our app, via "mixins" only.


1.back end service
  service which is having application logic.

2.front end service /api gate way service.
  Service which exposes apis are as "Rest End points".


API GateWay:
 - Front End through which only http requests are processed.


								----Back End Services
 HTTP Client------request------|--|--APIGATEWAY-----|REST Api-----{
								----Back End Services


moleculer-web:	Official API Gateway service.

API GATE Implementation:
Molecular provides lot of modules 

1.moleculer-web

moleculer-web is official gatway module, which is built on express.js

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");

const broker = new ServiceBroker();

// Load API Gateway
broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: "/api",
            whitelist: [
                // Access any actions in 'hello' service
                "hello.*",
            ]
        }]
    }
});

broker.createService({
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello() {
            return 'Hello,Molecular'
        }
    }
});

async function init() {
    try {
        await broker.start();
        }
    catch (e) {
        log(e);
    }
}
init();

//url mapping;
//http://localhost:3000/api/hello/sayHello

///////////////////////////////////////////////////////////////////////////////////////

URL Mapping Rules:

1.ApiGateService -----Service Name ----ActionName mapping

2.Aliases:
.........
You can use alias names instead of action names. You can also specify the method. 
Otherwise it will handle every method types.

broker.createService({
    mixins: [ApiService],

    settings: {
        routes: [{
            aliases: {
                "GET users": "users.list",
                "GET users/:id": "users.get",
                "POST users": "users.create",
                "PUT users/:id": "users.update",
                "DELETE users/:id": "users.remove"
            }
        }]
    }
});

eg:
broker.createService({
    name:'apigateway',
    mixins:[ApiGateWayService],
    settings: {
        routes:[{
            path:"/api",
            aliases: {
               "hello": "hello.sayHello"
            }
        }]
    }
});

broker.createService({
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello() {
            return 'Hello,Molecular'
        }
    }
});

async function init() {
    try {
        await broker.start();
        }
    catch (e) {
        log(e);
    }
}
init();

Short cut for CREATING CURD REST END Points:

broker.createService({
    mixins: [ApiService],

    settings: {
        routes: [{
            aliases: {
                "REST users": "users"
            }
        }]
    }
});

if you follow the above one you need to have actions names

To use this shorthand alias, create a service which has list, get, create, update and remove actions.
const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");

const broker = new ServiceBroker();

////url mapping;
//http://localhost:3000/api/hello/sayHello

// Load API Gateway
// broker.createService({
//     name: 'ApiGateWayService',
//     mixins: [ApiGateWayService],
//     settings: {
//         routes: [{
//             path: "/api",
//             whitelist: [
//                 // Access any actions in 'hello' service
//                 "hello.*",
//             ]
//         }]
//     }
// });


//http://localhost:3000/api/hello/

broker.createService({
    name: 'apigateway',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: "/api",
            aliases: {
                "hello": "hello.sayHello",  //here GET Is default
                // "GET hello": "hello.sayHello",
                "REST users": "users"
            }
        }]
    }
});

broker.createService({
    name: 'users',
    actions: {
        list: {
            handler(ctx) {
                return 'List'
            }
        },
        get: {
            handler(ctx) {
                return 'Get'
            }
        },
        create: {
            handler(ctx) {
                return 'create'
            }
        },
        update: {
            handler(ctx) {
                return 'update'
            }
        },
        remove: {
            handler(ctx) {
                return 'remove'
            }
        }
    }
});

broker.createService({
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello() {
            return 'Hello,Molecular'
        }
    }
});

async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();
..............................................................................................
					Database Adapters
..............................................................................................


moleculer-db

	Moleculer service to store entities in database

Features
default CRUD actions
cached actions
pagination support
pluggable adapter (NeDB is the default memory adapter for testing & prototyping)
official adapters for MongoDB, PostgreSQL, SQLite, MySQL, MSSQL.
fields filtering
populating
encode/decode IDs
entity lifecycle events for notifications

const { ServiceBroker } = require("moleculer");
const DbService = require("moleculer-db");

const broker = new ServiceBroker();

// Create a DB service for `user` entities
broker.createService({
    name: "users",
    mixins: [DbService],

    settings: {
        fields: ["_id", "username", "name"]
    },

    afterConnected() {
        // Seed the DB with ˙this.create`
    }
});

async function init() {
    try {
        await broker.start();
        await broker.call("users.create", {
            username: "john",
            name: "John Doe",
            status: 1
        })
        const users = await broker.call("users.find");
        console.log(users);
    }
    catch (e) {
        log(e);
    }
}
init();
..............................................................................................

                                       Moleculer Runner

-Helper script to create realtime projects

-all necessary configuration.
  -GATEWAY
  -Transporter
  -Database integration
  -Docker/Kb integration
  -Monitoring tool integration


Steps:

1.install
npm i -g moleculer-cli

2.Create Project
$ moleculer init project my-project























 














